# Tiny React

> React のコアランタイム（Fiber、Hooks、スケジューラー、レンダリングロジックなど）を簡素化して再実装した学習・実験用プロジェクトです。

---

## ✨ 特徴

- 🧠 **Fiber アーキテクチャ** – React の並列レンダリング機構を再現
- 🔁 **Reconciler & Commit フェーズ** – 更新と副作用の分離、DOM の差分検出
- ⚙️ **Hooks システム** – `useState`、`useEffect`、`useRef`、`useReducer` などに対応
- 🎯 **タスクスケジューラー** – 最小ヒープを用いた協調的スケジューリング
- 🌐 **シングルページのデモルーティング** – URL で異なるデモを切り替え

---

## 使い方

```bash
pnpm install
pnpm dev
pnpm build
```

## デモ例

### ローカルでアクセス

| デモ名    | URL          | 説明                                     |
| --------- | ------------ | ---------------------------------------- |
| useState  | `/useState`  | 状態更新 + 再レンダーの基本動作          |
| useEffect | `/useEffect` | 副作用のスケジューリングとクリーンアップ |
| useRef    | `/useRef`    | 複数レンダー間の参照保持                 |
| ...       | ...          | その他のデモはコード参照                 |

詳細は demo/route/settings.tsx をご覧ください。

### オンライン版

近日公開予定…

## 感想

React を学び始めた頃、Scheduler や Reconciler、Renderer の構造や、useEffect の非同期実行、useLayoutEffect の実行タイミングなど、一通りの理論は調べました。

でも正直、「なぜ動くのか」は全く分かっていませんでした。
例えば setState を呼ぶと何が起きて、どうして再レンダーが行われるのか、それは完全にブラックボックスでした。

私は昔から「ブラックボックス」が苦手です。
「別に中身を知らなくても使えればいい」という考え方もありますし、心の健康のためには知らない方が楽かもしれません。
実際、全員がフレームワークを作るわけではないですし、日常の開発には問題ないでしょう。
でも私は「何も知らない」状態がどうしても嫌でした。
特にこの時代、自分が成長を止めた瞬間、AI に取って代わられるのは自分かもしれません。

React に入る前、私は Vue のリアクティブシステムを簡易的に実装したことがあります。
diff や patch は書かなかったけれど、effect・track・trigger を自分で実装したことで、「computed は dirty チェック + effect でできている」ことを初めて実感できました。

今では Vue を見ても、もうブラックボックスには見えません。
proxy がどう使われているのか理解できていますし、Vue2 の頃のように created で再帰的に Object.defineProperty を使う必要もありません。
モダンブラウザの ES6 対応と Vite の軽快なビルド環境のおかげで、Vue3 は Webpack 時代のような遅さも感じません。

もちろん、ここまで理解するのは簡単ではありませんでした。
数年前の私は npm run serve が何なのかすら知りませんでした。
でも今では Webpack の仕組み（entry → loader → bundle → output）を理解できています。
でも、フロントエンドは Vue だけじゃありません。React という巨大な山もあります。

今回は、ぼんやりとした理解から出発して、React の内部構造をとことんまで追いかけました。
たくさんの壁にぶつかりました。特に fiber のデバッグは非常に難しく、入れ子の linked list 構造は理解も実装も大変でした。

beginWork で children を diff し、alternate と比較、2 回目の走査では Map を使って O(1) で探索・追加・削除を行います。

completeWork で更新や ref のフラグを立て、DOM を再利用、情報を親に伝搬します。

workLoop の DFS が終わったら commitWork に入り、

beforeMutation で古い ref を削除

mutation で DOM を操作

fiber ツリーの切り替え

layout で ref のマウント、useLayoutEffect の実行

最後に useEffect が非同期で実行されます

ある瞬間、「わかった！」という感覚がありました。

特に印象に残ったのは：

Hooks の仕組み：memorizedState に hooks の linked list を保持し、updateWorkInProgressHook を通じて順番に値を取得。名前ではなく呼び出し順で管理するのがすごい。

Hooks + Fiber のリングバッファ構造：こんな構造は見たことがなく、とても新鮮でした。

Scheduler の時間分割実行：優先度を管理するためのヒープ構造は見慣れているけど、MessageChannel を使ってマクロタスクをスケジューリングする方法は初体験で、将来の pub-sub 実装にも応用できそう。

タイムスライシング：再帰ではなく、途中で return しながら分割実行する記述スタイル。「再帰狂」だった自分にとって、コールスタックの限界を実感し、新しい視点を得ました。

抽象的に見ると、Vue と React の哲学は案外シンプルに感じました。

Vue：オブザーバーパターン（reactive + effect）。コンパイル後の render 関数が effect となり、コンポーネント単位で更新。

React：イベントドリブン（useReducer の dispatch で再レンダー）。diff を通して必要な箇所だけを更新。

要するに：

Vue：データが変わると、そのコンポーネントだけ再レンダー

React：dispatch すると全体が再レンダーされ、必要な部分だけ更新される

きっと、シンプルこそが真理なのだと思います。
でももし、いつか真理を発見しても、それを実現する力がなかったとしたら……それはとても悔しいことです。
だから私は前へ進み続けます。止まりません。

未来の私は、きっと今の自分に感謝するでしょう。

```

```
